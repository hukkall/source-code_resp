---
title: 416.分割等和子集
tags:
  - 算法
  - 动态规划
abbrlink: 7c6d07f7
date: 2020-07-07 16:31:23
---

# 题目

给定一个只包含**正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**注意:**

每个数组中的元素不会超过 100
数组的大小不会超过 200
**示例 1:**

```
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

**示例 2:**

```
输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
```

# 理解

​	题目的两个子集的和相等代表着原来数组的和应该是一个偶数，不然分成两个子集之后，他们的和就不能相等，这是需要判断的一个点。

​	这个问题可以转化为一个0-1背包问题，使用一个二维数组`dp[i][s]`来表示：

> 能否从`[0,i]`的范围内选择一些数字，使得选出来的数字之和恰好等于s。

​	我们先看看最基础的状态，比如`dp[i][0]`这种情况，不管能选多少个数字，我一个都不选，肯定能满足他们之和为0，所以`dp[i][0]`恒为`true`，还有`dp[0][s]`的情况，我没有数字可以选择，怎么我都凑不齐你要的`s`，所以除了`dp[0][0]`以外的所有`dp[0][s]`的值恒为`false`。

​	根据上面的定义，满足题意的解答是`dp[len][sum/2]`，其中`len`是数组的长度，`sum`是数组的各元素之和。

​	基础状态有了，`dp`数组的含义也有了，那么就要研究下状态转移了。

​	对于当前的数字`nums[i]`，考虑**选择**还是**不选**：

> 不选择： 那么`dp[i][s]`的值就等于上一次的值，因为这次你没有做任何改变，继承了上一次的值，即`dp[i][s] = dp[i-1][s]`
>
> 选择： `dp[i][s]`的值取决上一次选择范围内`[0,i-1]`，有没有数字的和等于`s-nums[i]`。即`dp[i][s] = dp[i-1][s-nums[i-1]]`  。
>
> 为什么是`nums[i-1]`? 	因为`dp`数组的`i`从1开始算，所以比`nums`数组的大1。
>
> 为什么是`s-nums[i-1]`? 	因为如果上一次选择范围内有数字之和等于`s-nums[i-1]`，那么我这次加上`nums[i-1]`肯定是可以满足和等于`s`的。

​	

​	**为什么从1开始呢？**		因为基础状态已经算出`i`为`0`的情况和`s`为`0`的情况了。



​	对于**示例一**而言：

>当然这下面的负数索引在正式编程里会排除掉：
>
>`j - nums[i - 1] < 0`	//代表**和**比待加上去的数小，这在这个正整数数组里是不可能的，换言之就是说背包容量不足了。
>
>`dp[i][s]=dp[i-1][s]`//只能让他的状况保持原来不变了。
>
>
>
>`dp[1][1] = dp[0][1] || dp[0][1-1]` 根据基础状态可得为真
>
>`dp[1][2] = dp[0][2] || dp[0][2-1]` 根据基础状态可得为假
>
>... 
>
>一直到`dp[1][11] ` 都为假。
>
>`dp[2][1] = dp[1][1] || dp[1][1-5]` 根据之前记录的`dp[1][1]`可得，为真。
>
>`dp[2][2] = dp[1][2] || dp[1][2-5]` 根据之前的记录`dp[1][2]`可得，为假。
>
>...
>
>`dp[2][5] = dp[1][5] || dp[1][5-5]` 根据基础状态`dp[i][0]`可得，为真。
>
>`dp[2][6] = dp[1][6] || dp[1][6-1]`根据之前的记录`dp[1][1]`可得，为真。
>
>...
>
>一直到`dp[2][11]`都为假。
>
>...
>
>其余状态`dp[3][1...11]`、`dp[4][1...11]`同理。

最后返回的结果为`dp[4][11]`，也就是在整个数组范围`[1,4]`内，能不能找到一些数，使得他们之和为`11`，显然有的。

# 代码

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) return false;
        int sum = 0;
        for (int i = 0; i < len; i++) {
            sum += nums[i];
        }
        if (sum % 2 != 0) return false;
        sum /= 2;
        boolean[][] dp = new boolean[len + 1][sum + 1];
        for (int i = 0; i < len + 1; i++) {
            dp[i][0] = true;
        }
        for (int i = 1; i <= len; i++) {
            for (int j = 1; j <= sum; j++) {
                if (j - nums[i - 1] < 0) {
                    //容量不足
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[len][sum];
    }
}
```

