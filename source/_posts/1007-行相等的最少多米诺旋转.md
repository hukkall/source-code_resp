---
title: 1007 行相等的最少多米诺旋转
tags:
  - LeetCode
  - 贪心
  - 算法
index_img: >-
  https://rmt.dogedoge.com/fetch/~/source/unsplash/photo-1595490524991-bb5f6b2e948e?auto=format&fit=crop&w=500&q=75
abbrlink: 34f
categories: 算法
date: 2020-07-24 23:47:22
---

这我真没看出哪里有贪心了...

<!-- more --->

# 题目

在一排多米诺骨牌中，`A[i]` 和 `B[i]` 分别代表第 `i` 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 `1` 到 `6` 的数字同列平铺形成的 —— 该平铺的每一半上都有一个数字。）

我们可以旋转第 `i` 张多米诺，使得 `A[i]` 和 `B[i]` 的值交换。

返回能使 `A` 中所有值或者 `B` 中所有值都相同的最小旋转次数。

如果无法做到，返回 `-1`.

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/03/08/domino.png)

> **输入：** A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]
> **输出：** 2
> **解释：**
> 图一表示：在我们旋转之前， A 和 B 给出的多米诺牌。
> 如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。
> 示例 2：

> **输入：**  A = [3,5,1,2,3], B = [3,6,3,3,4]
> **输出：**  -1
> **解释：**
> 在这种情况下，不可能旋转多米诺牌使一行的值相等。

# 理解

​	第一想法是找到出现次数最多的数字`max`，再逐一翻转为`max`。若有一列不能做到，返回`-1`

​	其实还可以这样想：

​	如果给的多米诺数组是可以成功旋转的，那么目标数字必定会出现在所有的列中，对于**示例1**，可以观察得到，目标数字`2`出现在了每一列中。

​	我们不妨指定一列，比如`A[0]，B[0]`。我们尝试将数组`A`中的所有数字旋转成`A[0]`，前提条件是数组`B`对应位置是`A[0]`（要想把当前数字改变成A[0]，必须要有对应的数字可供旋转），或者说数组`A`当前位置的数字就是`A[0]`（不用旋转）。记录旋转次数`r_A`。

​	然后尝试将数组`B`中的所有数字旋转成`A[0]`，过程同理，记录旋转次数`r_A`，然后返回两个旋转次数的最小值`min`。如果两个操作都执行不了，就返回`-1`

​	上面两个操作都是尝试将两个数组都转换为`A[0]`，如果操作成功，就直接返回`min`，操作无法完成的话，就尝试将两个数组转换为`B[0]`。

# 代码

```java
class Solution {
    public int minDominoRotations(int[] A, int[] B) {
        int len = A.length;
        int res = check(A[0],A,B,len);//尝试将俩个数组的值旋转为A[0]
        if(res!=-1) return res;//操作成功，返回最小值
        else    return check(B[0],A,B,len);//否则执行将两个数组的值转换为B[0]
    }

    int check(int target, int[] A, int[] B, int len) {
        int r_A = 0;
        int r_B = 0;
        for (int i = 0; i < len; i++) {
            if(A[i]!=target&&B[i]!=target)  return -1;//如果这一列并不包含目标数字，肯定是失败的。
            else if(A[i]!=target)   r_A++;
            else if(B[i]!=target)   r_B++;
        }
        return Math.min(r_A, r_B);
    }
}
```

