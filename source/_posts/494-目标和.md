---
title: 494. 目标和
tags:
  - 算法
  - 动态规划
  - 背包问题变种
abbrlink: 9c78cf30
date: 2020-07-08 17:47:58
math: true
index_img: https://rmt.dogedoge.com/fetch/~/source/unsplash/photo-1484417894907-623942c8ee29
---

与动态规划作斗争-其二

<!-- more -->

# 题目

给定一个**非负整数**数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

**示例：**

**输入：**`nums: [1, 1, 1, 1, 1], S: 3`
**输出：**`5`
**解释：**

> -1+1+1+1+1 = 3
> +1-1+1+1+1 = 3
> +1+1-1+1+1 = 3
> +1+1+1-1+1 = 3
> +1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。

**提示：**

- 数组非空，且长度不会超过 20 。
- 初始的数组的和不会超过 1000 。
- 保证返回的最终结果能被 32 位整数存下。

# 理解

​	一开始我就想着是不是用深度优先搜索或者动态规划来做，我看了看题解，发现大部分人说会超时，最后还是用动态规划来做了。

​	参考评论区的大佬的说法：一般地，问题如果是从一个数组里面选择一些数字来组合成一个数，就可以化解成**0-1背包问题**。

这道题题目可以转化为：找到给定数组的一个正子集和负子集，使其的和为`target`
$$
\text{设P为正子集，N为负子集，U为整个数组。有：}\\
\Sigma{(P)}-\Sigma{(N)}=Target\\
\text{两边同时加上}\Sigma{(P)}-\Sigma{(N)}:\\
\Sigma{(P)}+\Sigma{(P)}-\Sigma{(N)}+\Sigma{(N)} = Target+\Sigma{(U)}\\
\text{即}	\\
2\cdot\Sigma{(P)}=Target+\Sigma{(U)}
$$

​	就是说在给定的数组里面找到一些数，他们的和的两倍是目标数字加上整个数组之和。换言之，如果目标数字加上整个数组之和不是个偶数，那么就肯定不存在这个正子集。这是一个判断条件。

​	那么按照动态规划的思路：

>- 定状态
>- 找基态
>- 写转移方程

​	我们一步一步来，先是定状态，前面我们已经讲过，这道题可以转换为背包问题来解决。一样的，我们的状态可以为**选取数的范围**（物品）以及**要凑成的数**（重量）这两种。很容易的，我们可以用一个二维数组`dp[i][j]`来表示对于索引`[0,i]`的数，我们能凑出`j`的方法数量。

​	状态我们明确了，那么就来找找最基础的状态了，根据背包问题的经验，`dp[0][0]`的方法数量始终为`1`，因为选择前`0`个数的时候，合成`0`的方法永远都是`1`，即什么都不选。

​	接下来就是我觉得动态规划最让人头疼的状态转移了，对于当前的`nums[i]`，有两种选择，要么加进背包，要么不加进去，由于我们是要求方法的数量，所以要把`nums[i]`没放进背包的情况的方法数量加上放进背包的情况。对于`dp[i][j]`，它的值等于:
$$
dp[i-1][j]+dp[i-1][j-nums[i]]\\
\text{没放进去}+\text{放进去了}
$$
这式子很好理解，没放进去的话，肯定继承了上一次的数量嘛；放进去的话，就要找一找上一次**没加上这个数**的时候的方法数量。

>我知道我这人没多久就会很难理解后面这句话的意思，所以趁着我现在大概能理解，赶紧讲明白：
>
>把后面的那个`dp[i-1][j-nums[i]]`的`j`当做现在的背包的总重量（就是已经把`nums[i]`装进去了），那么我想知道现在背包的总价值，那我是不是必须得知道没装这个物品的时候，我的背包的总价值？
>
>这个也同理嘛，想知道我加上这个数（`nums[i]`)之后一共有多少种方法合成当前的数字(`j`）？那我起码得知道没加进去（`dp[i-1][j-nums[i]]`）的时候有多少种方法嘛。

# 代码

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if ((S + sum) % 2 != 0 || sum < Math.abs(S)) return 0;
        int val = (S + sum) / 2;
        int[] dp = new int[val + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int j = val; j >= num; j--) {
                dp[j] = dp[j] + dp[j - num];
            }
        }
        return dp[val];
    }
}
```

​	那么我这里为什么只用了一个一维数组呢？因为我们观察状态转移方程可以知道：当前状态都是上一次状态转移过来的，我们可以用一个一维数组保存数据就可以了。其中`dp[i-1][j]`和代码中左侧的`dp[j]`是一样的，在为左边的`dp[j]`赋值的时候，右边的`dp[j]`还保存着上一次循环的值，对吧？`dp[j-num]`也同理。

​	还有，为什么要逆序？为了确保右边的`dp[j]`和`dp[j-num]`保存的还是之前的值，拿`dp[j-num]`来讲：

>设`dp[10]`等于`dp[10]+dp[10-4]`来讲，如果顺序更新，那我`dp[6]`是不是比`dp[10]`先更新？这就不符合我们的要求了嘛

​	还有，为什么要以当前的`num[i]`作为`j`的下限呢？你总没见过负数的索引吧？况且`j`可以看为当前的背包容量，如果背包容量不足以装下这个数字，那还装个🔨。