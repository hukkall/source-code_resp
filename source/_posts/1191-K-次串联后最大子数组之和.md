---
title: 1191. K 次串联后最大子数组之和
tags:
  - 算法
  - leetcode
  - java
index_img: https://rmt.dogedoge.com/fetch/~/source/unsplash/photo-1594293185787-c6705bb6eccf?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80
abbrlink: 897c
categories: 算法
date: 2020-07-10 16:10:25
---

一道最大子数组之和的变种

<!-- more -->

# 题目

给你一个整数数组 `arr` 和一个整数 `k`。

首先，我们要对该数组进行修改，即把原数组 `arr` 重复 `k` 次。

>  举个例子，如果 `arr = [1, 2]` 且 `k = 3`，那么修改后的数组就是 `[1, 2, 1, 2, 1, 2]`。

然后，请你返回修改后的数组中的最大的子数组之和。

注意，子数组长度可以是 `0`，在这种情况下它的总和也是 `0`。

由于 **结果可能会很大**，所以需要 **模（mod） 10^9 + 7** 后再返回。

**示例 1：**

> 输入：arr = [1,2], k = 3
> 输出：9

**示例 2：**

> 输入：arr = [1,-2,1], k = 5
> 输出：2

**示例 3：**

> 输入：arr = [-1,-2], k = 7
> 输出：0

**提示：**

- 1 <= `arr.length` <= 10^5
- 1 <= `k` <= 10^5
- -10^4 <= `arr[i]` <= 10^4

# 理解

​	

​	先明白一个概念：**子数组**是连续的，咱经验不够丰富在这上面纠结了半天。

​	一开始我以为也是用动态规划来写，第一个测试用例倒是通过了，其他的...

​	后来看一个大佬的[写法](https://leetcode.jp/leetcode-1191-k-concatenation-maximum-sum-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af%e5%88%86%e6%9e%90/)，感觉他讲的非常好，我尝试用自己的话复述一遍：

>这道题意思就是要我们找出一个连续子区间，并计算出他们的和。
>
>那么，这个区间会出现在哪里呢？
>
>1. 单独数组的中间部分
>2. 数组头和数组尾
>3. 数组尾+（K-2）*数组和+数组头
>
>为啥呢？可以看看下面的例子

## 第一种情况：

设`arr[5] = {-1000,2,3,4,-9956}`，很容易就能看出他们的最大连续子区间就是中间那几个，我们把它重复几次：

`{-1000,2,3,4,-9956,-1000,2,3,4,-9956,-1000,2,3,4,-9956,-1000,2,3,4,-9956,-1000,2,3,4,-9956}`

可以很容易看出，无论重复多少次，最大连续子区间都是`{2,3,4}`，他们的和是`9`

## 第二种情况：

一样的，设`arr[5]={7，8，5，-999，6}`，将它重复几次：

` {7，8，5，-999，6,7，8，5，-999，6,7，8，5，-999，6,7，8，5，-999，6}`

无论重复多少次，它的最大连续子区间都是`{6,7,8,5}`即数组尾和数组头。他们的和是`26`

## 第三种情况：

设`arr[5]={-8,56,3,1,23}`,将它重复**5**次（以`|`作为分隔符，便于我的理解）：

`{-8,56,3,1,23,|,-8,56,3,1,23,|,-8,56,3,1,23,|,-8,56,3,1,23,|,-8,56,3,1,23}`

仔细看看并思考，如果求**最大**的子数组的话，那我是不是应该从第一个数组的`{56,3,1,23}`开始加，加上中间**3（5-2）**个数组的和，再加上最后一个数组的`{-8,56,3,1,23}`，使得子数组之和最大。

其中第一个数组的`{56,3,1,23}`这一部分叫做数组尾，中间三个数组之和可以为`(K-2)*Σ(arr)`，加上最后一个数组的数组头。其中，数组头可以是整个数组，数组尾也同理。

  

  

综上所述，我们可以求出上面三种情况的最大值，并选择其中最大的返回即可。且易得`K`等于`1`的时候，只需要考虑第一种情况就够了。因为剩下两种都是需要重复（即`K>=2`）才行。

# 代码

```java
class Solution {
    public int kConcatenationMaxSum(int[] arr, int k) {
        long prefix = 0;//当前数组前缀和
        long max_prefix = 0;//最大前缀和

        long suffix = 0;//当前数组后缀和
        long max_suffix = 0;//最大后缀和

        long midSum = 0;//当前数组中间值的和
        long max_midSum = 0;//最大中间和

        final int mod = (int) (Math.pow(10, 9) + 7);
        for (int i = 0; i < arr.length; i++) {
            prefix += arr[i];
            max_prefix = Math.max(prefix, max_prefix);


            suffix += arr[arr.length - 1 - i];
            max_suffix = Math.max(suffix, max_suffix);

            if (midSum < 0) midSum = arr[i];//如果中间值的和小于0，加上当前的数肯定是比当前数更小了，所以换成当前的数。
            else midSum += arr[i];//累加
            max_midSum = Math.max(max_midSum, midSum);
        }
        if (k == 1) return (int) (max_midSum % mod);
        else {
            int case1 = (int) (max_midSum % mod);
            int case2 = (int) ((max_prefix + max_suffix) % mod);
            int case3 = (int) ((max_prefix + max_suffix + prefix * (k - 2)) % mod);//为啥数组和是用前缀和来表示呢？因为你看上面的循环，prefix会一直累加直到数组末尾，所以他可以等同于数组和。
            return Math.max(Math.max(case1,case2),case3);
        }
    }
}
```

​	

需要注意的是，每个和都需要是长整型，不然容易计算出错。