---
title: 598 范围求和
tags:
  - LeetCode
  - 算法
typora-root-url: ..
index_img: >-
  https://rmt.dogedoge.com/fetch/~/source/unsplash/photo-1579723132452-ff50a3acd299?auto=format&fit=crop&w=500&q=75
abbrlink: 8f1f
categories: 算法
date: 2020-07-27 15:38:13
---

一道数学题

<!-- more -->

# 题目

给定一个初始元素全部为 `0`，大小为 `m*n` 的矩阵 `M` 以及在 `M` 上的一系列更新操作。

操作用二维数组表示，其中的每个操作用一个含有两个正整数 `a` 和 `b` 的数组表示，含义是将所有符合 `0 <= i < a` 以及 `0 <= j < b` 的元素 `M[i][j]` 的值都增加 `1`。

在执行给定的一系列操作后，你需要返回矩阵中含有**最大整数**的元素个数。

**示例 1:**

```
输入: 
m = 3, n = 3
operations = [[2,2],[3,3]]
输出: 4
解释: 
初始状态, M = 
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

执行完操作 [2,2] 后, M = 
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

执行完操作 [3,3] 后, M = 
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。
```

**注意:**

1. m 和 n 的范围是 [1,40000]。
2. a 的范围是 [1,m]，b 的范围是 [1,n]。
3. 操作数目不超过 10000。

# 理解

​	第一眼感觉就是穷举，将所有操作都执行一遍，然后遍历一次，找到最大的数字，再遍历一次，用于统计数量。看了下`m`和`n`的范围，这必定超时。

​	官方题解说到，最大的数字一定是`M[0][0]`，因为所有操作都影响到了它。我们可以转换想法，去寻找被操作影响的区域的交集。因为它们都有一个共同的出发点，`M[0][0]`。如下图：

​	![image.png](/img/%60598-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C%60/26e0a0c8beab6fcc0edfc099a9188179210b6b627f5a77970b672338a99f864a-image.png)

​	上图中颜色较深的就是`操作1`和`操作2`的交集，可以看出，交集的长是由`操作1`的长决定的，类似的，交集的宽也是由`操作2`的宽决定的，它们分别都是对应操作集的最短的边。

​	可以联想到木桶原理，交集的大小取决于最小的操作集，也就是最短的长和最短的宽。

# 代码

```java
public int maxCount(int m, int n, int[][] ops) {
        int count = 0;
        for (int[] op : ops) {
            m = Math.min(m,op[0]);
            n = Math.min(n,op[1]);
        }
        return m*n;
    }
```

