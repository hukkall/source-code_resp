---
title: 17.10 主要元素
tags:
  - LeetCode
  - 摩尔投票
index_img: >-
  https://rmt.dogedoge.com/fetch/~/source/unsplash/photo-1595814411664-572a0201dc93?auto=format&fit=crop&w=500&q=75
abbrlink: 2a22
categories: 算法
date: 2020-07-27 19:40:39
math: true
---

一道很经典的利用摩尔投票算法的题目

<!-- more -->

# 题目

数组中占比超过一半的元素称之为主要元素。给定一个**整数**数组，找到它的主要元素。若没有，返回-1。

**示例 1：**

```
输入：[1,2,5,9,5,9,5,5,5]
输出：5
```

 

**示例 2：**

```
输入：[3,2]
输出：-1
```

 

**示例 3：**

```
输入：[2,2,1,1,1,2,2]
输出：2
```

 

**说明：**
 你有办法在时间复杂度为$O(N)$，空间复杂度为 $O(1)$内完成吗？

# 理解

​	第一感觉就是哈希表计数，然后比较大小并输出。但是这样的话就不满足题目要求的空间复杂度为$O(1)$的要求了。

​	还有一种是比较通用的求众数的方法，叫做**摩尔投票**。核心思想是在一个数组里面，存在一个数，它的出现次数是整个数组的长度的一半，摩尔投票算法所做的是从这个数组里，每次选出两个不同数字，一起删除，直到剩下一个数字或者几个相同的数字，那么剩下的就是众数了。

​	更通俗易懂一点的话就是：

>跟鬼子肉搏。1打1会同归于尽。要想获胜只能使用人海战术，最起码要比鬼子人数多一个，也就是大于$\frac{n}{2}$

​	理解了这个就好办了，我们维护一个变量`major`，用于保存当前遇到最多的数字，另一个变量`count`，用于保存`major`的数量。遇到与`major`不同的数字的时候，`count`自减，当`count`归零的时候，将当前的数字变成新的`major`，并将`conut`初始化为`1`。

# 代码

```java
class Solution {
    public int majorityElement(int[] nums) {
        int major = 0;//当前的出现次数最多的数字
        int count = 0;//出现次数
        for (int i = 0; i < nums.length; i++) {
            if (count != 0) {
                if (nums[i] != major) {//不同的数字两两抵消
                    count--;
                } else {
                    count++;//相同的话就更新
                }
            } else {
                major = nums[i];//计数器归零的时候，更新为当前数字
                count = 1;
            }
           
        }
        return major;
    }
}
```

​	很奇怪的是，没有出现过`-1`这种情况，不然的话，后面还要遍历一次数组，确保出现次数超过数组长度的一半，毕竟摩尔投票算法得到的是众数，并不确保出现次数超过数组长度的一半。